<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="description" content="">
	<meta name="author" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Potree Viewer</title>

	<link rel="stylesheet" type="text/css" href="../build/potree/potree.css">
	<link rel="stylesheet" type="text/css" href="../libs/jquery-ui/jquery-ui.min.css">
	<link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css">
	<link rel="stylesheet" type="text/css" href="../libs/spectrum/spectrum.css">
	<link rel="stylesheet" type="text/css" href="../libs/jstree/themes/mixed/style.css">
</head>

<body>
	<script src="../libs/jquery/jquery-3.1.1.min.js"></script>
	<script src="../libs/spectrum/spectrum.js"></script>
	<script src="../libs/jquery-ui/jquery-ui.min.js"></script>
	<script src="../libs/three.js/build/three.js"></script>
	<script src="../libs/other/BinaryHeap.js"></script>
	<script src="../libs/tween/tween.min.js"></script>
	<script src="../libs/d3/d3.js"></script>
	<script src="../libs/proj4/proj4.js"></script>
	<script src="../libs/openlayers3/ol.js"></script>
	<script src="../libs/i18next/i18next.js"></script>
	<script src="../libs/jstree/jstree.js"></script>
	<script src="../build/potree/potree.js"></script>
	<script src="../libs/plasio/js/laslaz.js"></script>
	<script src="../libs/other/stats.min.js"></script>

	<script src='../libs/sql.js/sql-wasm.js'></script>
	<script src='../libs/geopackage/geopackage.js'></script>
	<script src="../libs/three.js/extra/lines/LineSegmentsGeometry.js"></script>
	<script src="../libs/three.js/extra/lines/LineGeometry.js"></script>
	<script src="../libs/three.js/extra/lines/LineMaterial.js"></script>
	<script src="../libs/three.js/extra/lines/LineSegments2.js"></script>
	<script src="../libs/three.js/extra/lines/Line2.js"></script>

	<div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; ">
		<div id="potree_render_area">
			<input type="button" id="record" value="record" style="position: absolute; bottom: 10px; left: 10px; z-index: 1000">
			<input type="button" id="play" value="play" style="position: absolute; bottom: 10px; left: 100px; z-index: 1000">
			<input type="button" id="reset" value="reset" style="position: absolute; bottom: 10px; left: 200px; z-index: 1000">
		</div>
		<div id="potree_sidebar_container"> </div>
	</div>
	
	<script>
	
		window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));
		
		viewer.setEDLEnabled(false);
		viewer.setFOV(60);
		viewer.setPointBudget(3_000_000);
		viewer.loadSettingsFromURL();
		
		viewer.loadGUI(() => {
			viewer.setLanguage('en');
			// $("#menu_tools").next().show();
			viewer.toggleSidebar();
		});
		
		Potree.loadPointCloud("../pointclouds/gane/cloud.js", "gane", e => {
			let scene = viewer.scene;
			let pointcloud = e.pointcloud;
			
			let material = pointcloud.material;
			material.size = 1;
			material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
			material.shape = Potree.PointShape.SQUARE;
			
			scene.addPointCloud(pointcloud);
			
			scene.view.position.set(2561552.953, 1205235.904, 583.922);
			scene.view.lookAt(2561660.435, 1205178.339, 474.808);
			//viewer.fitToScreen();
		});
		
	</script>


	<script>

	const curveType = "chordal";
	
	const records = [];

	function record(){

		const camera = viewer.scene.getActiveCamera();
		const record = camera.clone();

		// [r85] workaround because camera.clone() doesn't work on rotation
		record.rotation.set(...camera.rotation.toArray()); 
		record.rotation.order = camera.rotation.order;

		records.push(record);

		console.log("current camera recorded");
	}

	function play(){
		console.log("playing recorded");

		let positions = records.map(r => r.position);
		let directions = records.map(r => r.getWorldDirection());
		let targets = positions.map( (pos, i) => {
			return pos.clone().add(directions[i].clone().multiplyScalar(100));
		});

		let normalizeCurve = (points) => {
			let curve = new THREE.CatmullRomCurve3(points);
			curve.curveType = curveType;

			let newPoints = [];
			let t = 0;
			let step = 0.01;
			let targetDist = 1;
			let failedTries = 0;
			newPoints.push(curve.getPoint(0));
			while(t < 1){
				
				let previous = newPoints[newPoints.length - 1];

				let newT = t + step;
				let newPoint = curve.getPoint(newT);
				let newDist = newPoint.distanceTo(previous);
				let percentageOff = newDist / targetDist;
 
				while(Math.abs(percentageOff - 1) > 0.1){
					newPoint = curve.getPoint(newT);
					newDist = newPoint.distanceTo(previous);
					percentageOff = newDist / targetDist;

					if(Math.abs(percentageOff - 1) < 0.1){
						break;
					}
					
					let u = 1 / (1 + (percentageOff - 1) / 4);
					
					newT = t + (newT - t) * u;
				}

				newPoints.push(newPoint);
				t = newT;
			}

			return newPoints;
		};

		
		let animate = () => { // animate camera
			let posCurve = new THREE.CatmullRomCurve3(normalizeCurve(positions));
			posCurve.curveType = curveType; // "centripetal"
			//posCurve.tension = 0.5;
			let targetCurve = new THREE.CatmullRomCurve3(normalizeCurve(targets));
			targetCurve.curveType = curveType;
			//targetCurve.tension = 0.5;

			let animationDuration = 5 * 1000;
			//let easing = TWEEN.Easing.Quartic.Out;
			let easing = TWEEN.Easing.Linear.None;

			let value = {x: 0};
			let tween = new TWEEN.Tween(value).to({x: 1}, animationDuration);
			tween.easing(easing);

			tween.onUpdate(() => {
				let t = value.x;
				
				let position = posCurve.getPoint(t);
				let target = targetCurve.getPoint(t);
				
				viewer.scene.view.position.copy(position);
				viewer.scene.view.lookAt(target);
				
			});

			tween.start()
		}

		let debug = () => {
			if(typeof splineObject !== "undefined"){
				viewer.scene.scene.remove(splineObject);
			}

			let sg = new THREE.SphereGeometry();
			var sm = new THREE.MeshNormalMaterial();

			const tStart = performance.now();

			let length = 0;
			for(let i = 1; i < positions.length; i++){
				length += positions[i].distanceTo(positions[i - 1]);
			}
			// let n = length / 

			let curve = new THREE.CatmullRomCurve3(positions);
			curve.curveType = curveType;

			let newPositions = [];
			let t = 0;
			let step = 0.01;
			let targetDist = 1;
			let failedTries = 0;
			newPositions.push(curve.getPoint(0));
			while(t < 1){
				
				let previous = newPositions[newPositions.length - 1];

				let newT = t + step;
				let newPoint = curve.getPoint(newT);
				let newDist = newPoint.distanceTo(previous);
				let percentageOff = newDist / targetDist;
 
				while(Math.abs(percentageOff - 1) > 0.1){
					newPoint = curve.getPoint(newT);
					newDist = newPoint.distanceTo(previous);
					percentageOff = newDist / targetDist;

					if(Math.abs(percentageOff - 1) < 0.1){
						break;
					}
					
					let u = 1 / (1 + (percentageOff - 1) / 4);
					
					newT = t + (newT - t) * u;
				}

				newPositions.push(newPoint);
				t = newT;
			}

			curve = new THREE.CatmullRomCurve3(newPositions);
			curve.curveType = curveType;


			let points = [];

			for(let i = 0; i <= 50; i++){
				let t = i / 50;
				
				let point = curve.getPoint(t);

				var s = new THREE.Mesh(sg, sm);
				s.position.copy(point);
				viewer.scene.scene.add(s);
				
				points.push(point);	
			}

			const tEnd = performance.now();
			const duration = (tEnd - tStart).toFixed(3);
			console.log(duration);

			var geometry = new THREE.BufferGeometry().setFromPoints( points );

			var material = new THREE.LineBasicMaterial( { color : 0xff0000 } );
			var splineObject = new THREE.Line( geometry, material );

			viewer.scene.scene.add(splineObject)
		}

		debug();
		animate();
	}

	function reset(){
		records.length = 0;
	}


	document.getElementById("record").addEventListener("click", record);
	document.getElementById("play").addEventListener("click", play);
	document.getElementById("reset").addEventListener("click", play);
	
	</script>

	<script>
	
		const animation = new Potree.CameraAnimation(viewer);


		const positions = [
			[2561604.110, 1205144.614, 506.316],
			[2561636.659, 1205092.107, 531.116],
			[2561794.931, 1205133.685, 526.014],
			[2561766.287, 1205257.661, 504.061],
		];

		const targets = [
			[2561661.3826, 1205205.354, 499.103],
			[2561688.0231, 1205179.031, 495.643],
			[2561731.4984, 1205200.228, 496.542],
			[2561717.1368, 1205228.523, 499.399],
		];

		for(let i = 0; i < positions.length; i++){
			const cp = animation.createControlPoint();

			cp.position.set(...positions[i]);
			cp.target.set(...targets[i]);
		}

		const frustum = animation.createFrustum();
		
		frustum.position.set(2561661.3826, 1205205.354, 499.103);
		frustum.scale.set(20, 20, 20);
		viewer.scene.scene.add(frustum);
		
	</script>

	<script>
	
	viewer.onGUILoaded(() => {
		
		let section = $(`
			<h3 id="menu_meta" class="accordion-header ui-widget"><span>Camera Animation</span></h3>
			<div class="accordion-content ui-widget pv-menu-list"></div>
		`);
		let content = section.last();
		content.html(`
		<div class="pv-menu-list">
			<span>Time: </span><span id="lblTime"></span> <div id="sldTime"></div>
		</div>
		`);

		content.find('#sldTime').slider({
			value: 0,
			min: 0,
			max: 1,
			step: 0.001,
			slide: (event, ui) => { 
				console.log(ui.value);
			}
		});


		section.first().click(() => content.slideToggle());
		section.insertBefore($('#menu_about'));
		
	});

	</script>
	
	
  </body>
</html>
